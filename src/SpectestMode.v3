// Copyright 2020 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Wrapper functions for executing WebAssembly spec tests (.bin.wast).
def OUT = Trace.OUT;
component SpectestMode {
	def group = OptionsRegistry.newGroup("SPECTEST", null);
	def expected = Strings.newMap<bool>();

	def SKIP_ACTIONS = group.newBoolOption("skip-actions", false, "Parse only and skip actions.");
	def EXPECTED = group.newPathOption("expected", null, "File containing expected failures to be ignored.")
		.onSet(TestUtil.loadExpectedFile(expected, _));
	
	// [rv]: reorganize
	def gen = U64Generator.new(114514);
	private def getGuard(obj: HostObject) -> u64 { return NumberedObject.!(obj).guard; }

	new() {
		WizengModes.runWast = run;
	}

	def run(engine: Engine, monitors: Range<Monitor>, files: Range<string>, args: Array<string>) -> int {
		if (files.length == 0) return 0;

		OUT.puts("##>");
		OUT.putd(files.length);
		OUT.ln();

		// [rv]: reorganize
		Target.getHostObjectGuardBytes = getGuard;

		var result = 0;
		for (f in files) result |= runTest(engine, monitors, f);
		return result;
	}

	def runTest(engine: Engine, monitors: Range<Monitor>, filename: string) -> int {
		OUT.puts("##+");
		OUT.puts(filename);
		OUT.ln();
		var input = System.fileLoad(filename);
		if (input == null) {
			OUT.puts("##-fail: could not load file").ln();
			return 1;
		}
		var before = System.ticksUs();
		var p = SpecTestParser.new(filename, input, makeExternRef(Vector.new(), _));
		p.parseFile();
		if (Trace.test) {
			var diff = System.ticksUs() - before;
			OUT.puts("##@");
			OUT.puts(filename);
			OUT.puts(" : ");
			OUT.putd(diff);
			OUT.puts(" us\n");
		}
		if (p.ok) {
			var ip = SpecTestInterpreter.new(engine, filename);
			if (monitors.length > 0) {
				ip.onMonitorsStart = Execute.tiering.onMonitorsStart;
				ip.onParse = fun (mod, err) {
					for (monitor in monitors) {
						monitor.onParse(mod, err);
						if (err.error()) return;
					}
				};
				ip.onMonitorsFinish = Execute.tiering.onMonitorsFinish;
				ip.onInstantiate = fun ins { for (monitor in monitors) monitor.onInstantiate(ins); };
				ip.onStart = fun f { for (monitor in monitors) monitor.onStart(f); };
				ip.onTest = fun (f, args) { for (monitor in monitors) monitor.onTest(f, args); };
				ip.onFinish = fun (ins, r) { for (monitor in monitors) monitor.onFinish(ins, r); };
			}
			ip.skip_actions = SKIP_ACTIONS.val;
			ip.ignore_failure = expected[filename];
			if (ip.run(p.commands)) {
				OUT.puts("##-ok").ln();
			} else {
				return 1;
			}
		} else if (expected[filename]) {
			OUT.put3("##-ok: (ignored expected failure: @ %d:%d %s)", p.error_loc.0, p.error_loc.1, p.error_msg).ln();
		} else {
			OUT.put1("##-fail: %s ", filename);
			OUT.put3("%d:%d %s", p.error_loc.0, p.error_loc.1, p.error_msg).ln();
			return 1;
		}
		return 0;
	}

	def makeExternRef(cache: Vector<HostObject>, i: int) -> HostObject {
		if (i >= cache.length || cache[i] == null) {
			var obj = NumberedObject.new(i);
			obj.guard = gen.next();
			cache.set(i, obj);
		}
		return cache[i];
	}
}

// Helper class for generating externref guards when {TestFeature.wideExtRef == true}.
class U64Generator(seed: u64) {
	var curr = seed;
	def next() -> u64 {
		curr = 9007199254740881ul * curr + 10039;
		return curr;
	}
}
